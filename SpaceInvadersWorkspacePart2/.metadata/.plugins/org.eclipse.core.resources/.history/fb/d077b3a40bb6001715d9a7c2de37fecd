/*
 * draw_saucer.c
 *
 *  Created on: Oct 20, 2017
 *      Author: superman
 */

#include "draw.h"
#include "draw_saucer.h"

#define SAUCER_Y_POSITION 29 // This is the Y position for when we draw the saucer.
#define SAUCER_MIN_X_POSITION -32 // The minimum X position for our saucer
#define SAUCER_MAX_X_POSITION 640 // The maximum X position for our saucer
#define SAUCER_MOVE 4 // How many pixels our saucer moves when it moves
#define SAUCER_ERASE_HEIGHT_OFFSET 6 // The amount down we need to know in order to erase.

uint16_t getSaucerPosition(){
	return saucerPosition;
}
void setSaucerPosition(uint16_t val){
	saucerPosition = val;
}

// This calculates the new x position for the saucer.
uint16_t update_saucer_x_position(){
	static int16_t x_position = RESET; // A static variable to to hold the x position

	if(saucer_move_right){
		x_position += SAUCER_MOVE; // If we are moving right increment our position.
	}
	else{
		x_position -= SAUCER_MOVE; // If we are moving left decrement our position.
	}

	if(x_position == SAUCER_MAX_X_POSITION){ // If we reach the max saucer position
		eraseExtraSaucerBits(x_position); // We need to erase the final bits of saucer
		saucer_move_right = FALSE; // We need to go left for next time.
	}
	else if(x_position == SAUCER_MIN_X_POSITION){ // If we reach the min saucer position
		eraseExtraSaucerBits(x_position); // We need to erase the final bits of saucer.
		saucer_move_right = TRUE; // We need to go right for next time.
	}
	return x_position;
}

uint8_t drawSaucer(){
	uint8_t line, pixel;

	int16_t x_position = update_saucer_x_position();
	//xil_printf("Draw saucer at x is : %d and y is : %d \n\r", x_position, SAUCER_Y_POSITION);
	setSaucerPosition(x_position);
	if((x_position == SAUCER_MAX_X_POSITION) || (x_position == SAUCER_MIN_X_POSITION)){
		return FALSE; // We need to stop the draw saucer functionality now that we have gone off the board.
	}

	if(x_position < LEFT_BORDER){ // We have some partial drawing to do when it gets to the left border.
		for(line = 0; line < SAUCER_HEIGHT; line++){ //For height
			for(pixel = 0; pixel < SAUCER_WIDTH; pixel++){ // So we need to do a smaller width because we are only drawing some of the saucer.
				if((pixel + x_position) >= RESET){
					if((saucer_symbol[line] & (SHIFT<<(SAUCER_WIDTH-SHIFT-pixel)))){
						if(frame_pointer[(line + SAUCER_Y_POSITION)*SCREEN_WIDTH + (pixel + x_position)] == BLACK){
							frame_pointer[(line + SAUCER_Y_POSITION)*SCREEN_WIDTH + (pixel + x_position)] = RED; //Set to red
						}
					}
					else{
						if(frame_pointer[(line + SAUCER_Y_POSITION)*SCREEN_WIDTH + (pixel + x_position)] == RED){
							frame_pointer[(line + SAUCER_Y_POSITION)*SCREEN_WIDTH + (pixel + x_position)] = BLACK; //Set to black
						}
					}
				}
			}
		}
		if(!saucer_move_right){
			eraseExtraSaucerBits(x_position);
		}

	}
	else if(x_position > (RIGHT_BORDER - SAUCER_WIDTH)){ // We have some partial drawing to do when it gets to the right border.
		for(line = 0; line < SAUCER_HEIGHT; line++){ //For height
			for(pixel = 0; pixel < (SCREEN_WIDTH - x_position); pixel++){ //
				if((saucer_symbol[line] & (SHIFT<<(SAUCER_WIDTH-SHIFT-pixel)))){
					if(frame_pointer[(line + SAUCER_Y_POSITION)*SCREEN_WIDTH + (pixel + x_position)] == BLACK){
						frame_pointer[(line + SAUCER_Y_POSITION)*SCREEN_WIDTH + (pixel + x_position)] = RED; //Set to red
					}
				}
				else{
					if(frame_pointer[(line + SAUCER_Y_POSITION)*SCREEN_WIDTH + (pixel + x_position)] == RED){
						frame_pointer[(line + SAUCER_Y_POSITION)*SCREEN_WIDTH + (pixel + x_position)] = BLACK; //Set to black
					}
				}
			}
		}
		if(saucer_move_right){
			eraseExtraSaucerBits(x_position);
		}
	}
	else{ // Erasing and drawing for normal operation.
		for(line = 0; line < SAUCER_HEIGHT; line++){ //For height
			for(pixel = 0; pixel < SAUCER_WIDTH; pixel++){ //For width
				if((saucer_symbol[line] & (SHIFT<<(SAUCER_WIDTH-SHIFT-pixel)))){
					if(frame_pointer[(line + SAUCER_Y_POSITION)*SCREEN_WIDTH + (pixel + x_position)] == BLACK){
						frame_pointer[(line + SAUCER_Y_POSITION)*SCREEN_WIDTH + (pixel + x_position)] = RED; //Set to red
					}
				}
				else{
					if(frame_pointer[(line + SAUCER_Y_POSITION)*SCREEN_WIDTH + (pixel + x_position)] == RED){
						frame_pointer[(line + SAUCER_Y_POSITION)*SCREEN_WIDTH + (pixel + x_position)] = BLACK; //Set to black
					}
				}
			}
		}
		eraseExtraSaucerBits(x_position);
	}
	return TRUE;
}
